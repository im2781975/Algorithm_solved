//There are 
N stones, numbered 
1,2,…,N. For each 
i (
1≤i≤N), the height of Stone 
i is 
h 
i
​
 .

There is a frog who is initially on Stone 
1. He will repeat the following action some number of times to reach Stone 
N:

If the frog is currently on Stone 
i, jump to Stone 
i-1 or Stone 
i+1. Here, a cost of 
∣h 
i
​
 −h 
j
​
 ∣ is incurred, where 
j is the stone to land on.
Find the minimum possible total cost incurred before the frog reaches Stone 
N.
#include <iostream>
#include <vector>
#include <cmath>

using namespace std;

int main() {
    int N; // Number of stones
    cin >> N;

    vector<int> h(N); // Heights of the stones
    for (int i = 0; i < N; i++) {
        cin >> h[i];
    }

    // Initialize a DP array to store the minimum cost to reach each stone
    vector<int> dp(N, 0);

    // Traverse through each stone
    for (int i = 2; i < N; i++) {
        dp[i] = min(dp[i - 1] + abs(h[i] - h[i - 1]), dp[i - 2] + abs(h[i] - h[i - 2]));
    }

    // The minimum cost to reach Stone N will be in dp[N-1]
    cout << dp[N - 1] << endl;

    return 0;
}

